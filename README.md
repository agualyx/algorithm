# 算法实验
## 第一次实验
* poj1753
  * 题目大意
    * 有 4x4 的正方形，每个格子要么是黑色，要么是白色，当把一个格子的颜色改变(黑->白或者白->黑)时，其周围上下左右(如果存在的话)的格子的颜色也被反转，问至少反转几个格子可以使 4*4 的正方形变为纯白或者纯黑？
  * 解题思路
    * 主要采用枚举的方法。由于当第一行的翻转情况定了之后，能够影响第一行的棋子的只有它们所对应的下一行的棋子，故我们只需要列出第一行的所有的翻转种类，共有2^4=16种，剩下的三行均根据上一行来翻转，这样每次翻转之后其实就只有第四行不是全白（黑），故我们在翻转完成之后只需要判断第四行是否是全白或全黑，如果是，则比较当前的最小步数并更新。对于每种翻转种类，我们都要枚举出全白和全黑两种，最后得到最小步数。共迭代32次。
* poj3295
  * 题目大意
    * 输入由 p、q、r、s、t、K、A、N、C、E 共 10 个字母组成的逻辑表达式，其中 p、q、r、s、t 的值为 1（true）或 0（false），即逻辑变量；K、A、N、C、E 为逻辑运算符，其中K --> and: x && y，A --> or: x || y，N --> not : ! x，C --> implies : (!x)||y，E --> equals : x==y。
  * 解题思路
    * 算法的主要思想：枚举、递归  
    * 共有五个变量，将它们的值一一列举需要2^5共32种，由于每个变量的取值只有0和1两种，故可以用0~31的二进制数的每个位来表示取值，这样就不用使用五层嵌套而是只使用二进制数的每个位来作为每个变量的取值，这样只用使用一层嵌套。  
    * 变量的表达式可以用栈来求解，当遇到大写字母时计算，也可以使用递归，当遇到符号时递归调用（其实函数的递归调用本质上就是一个栈）。

  
